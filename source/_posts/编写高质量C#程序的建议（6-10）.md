---
title: '编写高质量C#程序的建议（6-10）'
abbrlink: 2345
date: 2019-03-30 22:36:51
author: 玮仔Wayne
tags:
  - C#
  - 高质量代码
categories:
  - 读书笔记
---
[建议六：区别 readonly 和 const 的区别](#建议六：区别-readonly-和-const-的区别)
[建议七：将 0 作为枚举的默认值](#建议七：将-0-作为枚举的默认值)
[建议八：避免给枚举类型的元素提供显式的值](#建议八：避免给枚举类型的元素提供显式的值)
[建议九：习惯重载运算符](#建议九：习惯重载运算符)
[建议十：创建对象时需要考虑是否实现比较器](#建议十：创建对象时需要考虑是否实现比较器)
<!--more-->

## 建议六：区别 readonly 和 const 的区别
### const
const 是一个编译期常亮，用使用 const 的理由只有一个，那就是效率。const只能修饰基元类型、枚举类型或字符串类型。经过编译器编译后，我们在代码中引用 const 变量的地方会用 const 变量 所对应的实际值来代替，如，以下两句 WriteLine 语句的 IL 代码是一致的：
```cs
const int ConstValue = 100;

Console.WriteLine(ConstValue);
Console.WriteLine(100);
```

### readonly
readonly 是运行时常量，修饰类型没有限制。readonly 常量的复制行为发生在运行时，它在运行时第一次被赋值后将不可改变。
1. 对于值类型，之本身不可改变。
2. 对于引用类型，引用本身（指针）不可改变。

## 建议七：将 0 作为枚举的默认值
这里的主要原因是出于0作为默认值时所具有的工程上的意义。
原因参见以下代码：
```cs
enum Week
{
    Monday = 1,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
    Sunday
}

class Program
{
    static Week week;
    static void Main(string[] args)
    {
        Console.WriteLine(week);
    }
}
```
输出值会是超出枚举定义范围的 0。

## 建议八：避免给枚举类型的元素提供显式的值
一般情况下，没有必要给枚举类型的元素提供显式的值。创建枚举的理由之一，就是为了代替使用实际的数值。不正确的为枚举类型设定显式的值，会带来意想不到的错误。

```cs
enum Week
{
    Monday = 1,
    Tuesday = 2,
    TempValue，
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6,
    Sunday = 7
}
```
枚举中，未显式指定的值会自动等于上一个值 +1，所以在这个枚举类型 Week 中，TempValue 和 Wednesday 的值均为 3 ，这会在实际业务中带来毁灭性的问题。

```csharp
Week week= Week.TempValue；
Console.WriteLine(week);
Console.WriteLine(week == Week.Wednesday);
```
输出：
```bash
Wednesday
True
```
## 建议九：习惯重载运算符
如果业务意义上的加减乘除复制等运算，应该习惯于重载运算符，而不是使用普通方法。

## 建议十：创建对象时需要考虑是否实现比较器
有对象的地方就会存在比较，在 .NET 的世界中也一样。创建类型时需要根据业务上的可能性，考虑为类型实现 ICompareable 接口。